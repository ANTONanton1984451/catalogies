<?php


namespace parsing\platforms\google;

use parsing\platforms\Getter;
use Google_Client;

/**
 * Class GoogleGetter
 * @package parsing\platforms\google
 */
class GoogleGetter extends Getter
{
    const URL = 'https://mybusiness.googleapis.com/v4/';
    const PAGE_SIZE = '50';
    const HALF_YEAR = 15552000;

    private $client;
    private $curl;
    private $halfYearAgo;
    private $trigger;
    private $iterator = 0;
    private $nextPageToken = false;
    private $last_review_date;
    private $last_review_hash;

    /**
     * @var int
     * Дата последнего отзыва,лежащего в БД.
     */
    private $last_review_db;

    /**
     * GoogleGetter constructor.
     * @param Google_Client $client
     * @throws \Google_Exception
     * установка переменной,отсчитывающей временную метку в полгода
     */
    public function __construct(Google_Client $client)
    {
        $this->client = $client;

        $client->setAuthConfig(__DIR__.'\secret.json');

        $this->halfYearAgo=time()-self::HALF_YEAR;

    }


    /**
     * @param string $handled-флаг,говорящий методу о том,первичная ли это обработка ссылки или вторичная.
     * @return array
     * Функция,которая вызывает все остальные методы,получает массив данных с GMB_API в необработанном виде
     * При обнаружении отсутсвия отзывов или того,что уже совершилась последняя итерация,сразу же возвращает массив
     * с триггером,сообщающем о конце работы цикла.
     * При первичной обработке происходит получение всех отзывов за последние пол-года.
     * При вторичной обработке происходит сверка хэшей конфига и первого отзыва,
     * полученного в момент выполнения через GMB_API.
     * Сначала метод выполняет общие действия для обоих видов обработки,затем происходит разделение методов в зависимости
     * от флага $handled.
     *
     *
     */
    public function getNextReviews(string $handled):array
    {
        $this->iterator++;

        if($this->trigger == 'last_iteration'){

            $this->trigger='end';

            return ['trigger'=>$this->trigger];
        }

        $this->refreshToken();

        $google_request = $this->connectToPlatform();


        if(empty($google_request['reviews'])){

            $this->trigger = 'end';
            return ['trigger'=>$this->trigger];

        }elseif (!empty($google_request['nextPageToken'])){

            $this->nextPageToken = $google_request['nextPageToken'];

        }else{

            $this->trigger = 'last_iteration';
        }


        if($handled == 'NEW'){
                $this->firstIterate($google_request['reviews'][0]);

                $this->config['last_review_date'] = $this->last_review_date;
                $this->config['last_review_hash'] = $this->last_review_hash;

                $this->cutToTime($google_request['reviews'],$this->halfYearAgo);

        }elseif($handled == 'HANDLED'){

                $lastReviewFromGMB = $this->toHash($google_request['reviews'][0]);
                if($lastReviewFromGMB === $this->config['last_review_hash']){
                    $this->trigger = 'end';
                    return ['trigger'=>$this->trigger];
                }
                $this->firstIterate($google_request['reviews'][0]);

                $this->cutToTime($google_request['reviews'],$this->last_review_db);

                $this->config['last_review_date'] = $this->last_review_date;
                $this->config['last_review_hash'] = $this->last_review_hash;
        }

        return [
            'platform_info'=>$google_request,
            'config'=>$this->config,
            'trigger'=>$this->trigger
        ];

    }

    /**
     * @param $config
     * Небольшое дополнение метода родительского класса,не влияющее на работу всех классов
     */
    public function setConfig($config)
    {
        parent::setConfig($config); // TODO: Change the autogenerated stub
        $this->last_review_db = $config['last_review_date'];
    }


    public function getNotifications()
    {
        // TODO: Implement getNotifications() method.
    }

    /**
     * @param array $lastReview
     * Если происходит первая итерация цикла,то метод превращает массив в хэш-строку
     * для записи в специальную переменную
     * и записывает дату самого последнего по времени отзыва.
     */
    private function firstIterate(array $lastReview):void
    {
        if($this->iterator === 1){
            $this->last_review_hash = $this->toHash($lastReview);
            $this->last_review_date = strtotime($lastReview['updateTime']);
        }
    }


    /**
     * Обновляет токен и перезаписвает конфиги,записывая туда обновлённый токен токен
     */
    private function refreshToken():void
    {

        $this->client->setAccessToken($this->config['token_info']);

        if($this->client->isAccessTokenExpired()){

            $refreshToken = $this->client->getRefreshToken();
            $this->config['token_info'] = $this->client->fetchAccessTokenWithRefreshToken($refreshToken);

        }
    }

    /**
     * @param array|null $data-ссылка на массив данных,которые нужно проверить на актуальность по дате
     * @param int $timeBreak-дата,которая  используется при проверке.
     * Функция обрезает данные до установленной даты.
     * В случае достижения заданной даны,меняет триггер на last_iteration
     */
    private function cutToTime(?array &$data, int $timeBreak):void
    {

        for($i=0;$i<count($data);$i++){

            $timeStamp=strtotime($data[$i]['updateTime']);

            if($timeStamp >= $timeBreak ){
                continue;
            }
                $data=array_slice($data,0,$i);

                if(!$data){
                    $this->trigger = 'end';
                    return;
                }

                $this->trigger = 'last_iteration';
                return;

        }

    }

    /**
     * @return array|null
     * Метод подключается к сервисам гугл по данному $source.
     * Если имеется nextPageToken,то он используется,также формируется заголовок запроса с нужным токеном
     * Возвращает декодированный ответ от GMB_API
     */
    private function connectToPlatform():?array
    {
        if(!$this->nextPageToken){
            $request_url = self::URL.$this->source.'/reviews?pageSize='.self::PAGE_SIZE;
        }else{
            $request_url = self::URL.$this->source.'/reviews?pageSize='.self::PAGE_SIZE.'&pageToken='.$this->nextPageToken;
        }

        $this->curl = curl_init($request_url);

        $header_str = 'Authorization: '.$this->config['token_info']['token_type'].' '.$this->config['token_info']['access_token'];

        curl_setopt($this->curl,CURLOPT_HTTPHEADER,[$header_str]);
        curl_setopt($this->curl,CURLOPT_RETURNTRANSFER,true);

        $response = curl_exec($this->curl);

        return json_decode($response,true);
    }

    /**
     * @param array $review_array_row
     * @return string
     * Переводит массив в хэш строку
     */
    private function toHash(array $review_array_row):string
    {
        $implode_array = implode($review_array_row,'');
        return md5($implode_array);
    }

}